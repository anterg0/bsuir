<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<style>
		.cour {
			font-family: 'Courier New', Courier, monospace;
			font-weight: bold;
			font-size: 25pt;
			line-height: 1;
		}

		h1 {
			/*название раздела*/
			font-size: 40pt;
			text-align: center;
		}

		h2 {
			/*название параграфа*/
			font-size: 35pt;
		}

		h3 {
			/*?*/
			font-size: 30pt;
		}

		p {
			font-size: 25pt;
			line-height: 1;
		}

		figure img {
			width: 75%;
			height: 75%;
		}

		.fig {
			align-items: center;
			justify-content: center;
			display: block;
			text-align: center;
			margin-top: 0;
			margin-bottom: 100px;
			font-size: 23pt;
		}

		table,
		th,
		td {
			border: 1px solid black;
			border-collapse: collapse;
			padding: 10px;
			font-size: 25pt;
		}
	</style>

</head>
<body>
    <h1>11 Виды приложений и их структура, библиотеки</h1>
    <h2>11.1 Оверлеи</h2>
    <p>
        <b><i>Оверлеи</i></b> (<b><i>overlay</i></b>) – программные модули (библиотеки), готовые к загрузке и исполнению, но не самостоятельно, а в составе других программ. Оверлеи не находятся в памяти постоянно, а сменяют (перекрывают) друг друга по мере необходимости. <br>
    </p>
    <p>
        Использованием оверлеев решается ряд задач:<br>
        – <b><i>Экономия</i></b> памяти: загружена только часть кода и данных<br>
        – <b><i>Гибкость</i></b>: формирование нужной конфигурации программы в ходе ее загрузки<br>
        – <b><i>Структурирование</i></b> программы: компоновка ее из готовых модулей, в том числе созданных разными разработчиками и с помощью разных средств программирования<br>
    </p>


    <figure class="fig">
        <img src="./11-Оверлеи.png">
        <figcaption>Оверлеи</figcaption>
    </figure>

    <p>
        Варианты концепции оверлеев реализованы во многих системах: динамические библиотеки DLL в Windows (и OS/2), разделяемые библиотеки в Unix, и т.д. 
    </p>
    <p>
        Эффективное применение возможно при полноценной поддержке со стороны ОС (недостаточность которой в DOS ограничивало использование оверлеев, несмотря на остроту проблемы памяти).
    </p>


    <h2>11.2 Динамически подключаемые библиотеки (DLL)</h2>
    <h2>11.2.1 Назначение и структура DLL</h2>

    <p>
        <b><i>Динамически подключаемые</i></b> (<b><i>связываемые</i></b>) <b><i>библиотеки</i></b> (<b><i>Dynamic Link Library</i></b>, <b><i>DLL</i></b>) являются наряду с .EXE-файлами разновидностью исполняемых модулей в Windows в формате <b><i>Portable Executable</i></b> (<b><i>PE</i></b>): они имеют в целом аналогичную структуру, но не могут выполняться самостоятельно, а присоединяются к другим исполняемым файлам. Являясь разновидностью оверлеев, служат в целом тем же целям, изначально имеют поддержку системой.
    </p>
    <p>
        Сама ОС Windows представляет собой в значительной мере набор динамических библиотек, считающихся стандартными.
    </p>
    <p>
        Каждый модуль DLL включается в адресное пространство основного процесса, при этом каждое новое подключение модуля дает фактически новый его экземпляр, не зависящий от остальных экземпляров того же модуля. <br>(В Win16 все экземпляры модуля разделяли одно и то же адресное пространство, что усложняло программирование и снижало безопасность системы.)
    </p>
    <p>
        Загрузка библиотеки опирается на те же механизмы, что и соз­дание нового процесса. Ввиду того, что сегмент кода библио­теки может разделяться всеми его экземплярами, а вся библио­тека разделяется многими процессами и может загружаться ими многократно, для каждой библиотеки, загружаемой каждым процессом, создается счетчик привязок (загрузок), увеличивающийся при загрузке ее данным процессом и уменьшающийся при выгрузке. После обнуления счетчика библиотека удаляется из адресного пространства процесса.
    </p>
    <p>
        <span class="cour">.EXE</span>-файлы также могут загружаться аналогично, в адресном пространстве существующего процесса вместо порождения нового.
    </p>
    <p>
        Содержимое библиотеки (переменные, метки, функции, классы) недоступно (точнее, не известно) вне ее, за исключением специальным образом оформленных <b><i>экспортируемых символов</i></b>. Экспортируют в первую очередь функции и методы – API библиотеки. 
    </p>
    <p>
        Экспорт непосредственно данных (переменных) возможен и применяется, но чаще считается нежелательным. 
    </p>
    <p>
        Кроме символов, в библиотеке могут содержаться также ресурсы.
    </p>
    <p>
        Информация об экспортируемых символах помещается в <b><i>таблицу экспортируемых символов</i></b> модуля, откуда она считывается при подключении библиотеки в процессе <b><i>импорта</i></b> – получении точек доступа к символам.
    </p>
    <p>
        Экспортируемый символ идентифицируется его <b><i>именем</i></b> и <b><i>индексом</i></b> – порядковым номером в таблице. Имена в таблице экспортируемых символов не обязательно совпадают с их «внутренними» именами – компиляторы позволяют явно задавать «внешние» имена (см. ниже). Индексы символов не обязательно идут последовательно, т.к. также могут указываться явно.
    </p>


    <h2>11.2.2 Подключение (импорт) DLL</h2>
    <p>
        – <b><i>Явный импорт</i></b> (динамическое подключение) – в любой момент в процессе выполнения программы путем обращения к соответствующим системным вызовам
    </p>
    <p>
        – <b><i>Неявный импорт</i></b> (статическое подключение) – загрузку всех модулей и импорт символов осуществляет загрузчик до передачи управления «прикладной» точке входа, необходимая для этого информация включается в заголовок исполняемого файла компоновщиком (linker-ом).
    </p>
    <p>
        Явный импорт обеспечивает наибольшую гибкость и управляемость, возможность обработки ошибок, позволяет подстраиваться под любые соглашения об именах и форматах, но более трудоемок. Неявный импорт происходит прозрачно для программы, но требует соблюдения единых правил. Стандартные библиотеки, системные DLL подключаются неявно.
    </p>
        <h3>Явный импорт</h3>
    <p>
        Загрузка указанного DLL и включение его в адресное пространство процесса:
    </p>
    <p>
        <span class="cour">&nbsp;HINSTANCE LoadLibrary(LPCTSTR lpModuleName);</span>
    </p>
    <p>
        Получение описателя (Handle) уже загруженного модуля:
    </p>
    <p>
        <span class="cour">&nbsp;HMODULE GetModuleHandle(LPCTSTR lpModuleName);</span>
    </p>
    <p>
        Декремент счетчика загрузок библиотеки, после обнуления освобождение экземпляра библиотеки и исключение его из адресного пространства процесса:
    </p>
    <p>
        <span class="cour">&nbsp;BOOL FreeLibrary(HMODULE hModule);</span>
    </p>
    <p>
        Получение адреса функции или другого символа, импортиру­емого из библиотечного модуля, по имени или индексу:<br>– указатель на строку имени: <span class="cour">lpProc > 0xffff</span><br>– индекс: <span class="cour">lpProc <= 0xffff</span>
    </p>
    <p>
        <span class="cour">&nbsp;FARPROC GetProcAddress(	HMODULE hModule, LPCTSTR lpProc);</span>
    </p>
    <p>
        Возвращаемое значение – указатель на функцию вида <span class="cour">(__stdcall *)(void);</span> при экспорте символов другого типа требуется соответствующее его приведение. 
    </p>
    <p>
        Головная программа должна сохранить адреса импортированных символов в соответствующих переменных-указателях, возможно с приведением типа, и в дальнейшем использовать их при обращениях к объектам в DLL.
    </p>
        <h3>Неявный импорт</h3>
    <p>
        Для головной программы достаточно (в оптимистичном случае) включить декларации импортируемых символов при компиляции, обычно посредством заголовочных файлов <span class="cour">(*.h)</span>, и сгенерированные вместе с DLL «оберточные» библиотеки <span class="cour">(*.lib)</span> при компоновке. 
    </p>
    <p>
        После успешного завершения процедуры загрузки символы из библиотеки становятся доступными для головного модуля. В случае ошибки (обычно отсутствие необходимого модуля) процесс не создается, как правило, с выдачей сообщения о системной ошибке.
    </p>
    <p>
        Важное обстоятельство – согласование формата вызова функ­ций: в реализации библиотеки и в использующей ее программе.
    </p>
    <p>
        Формат точки входа DLL зафиксирован, т.к. к ней обращается операционная система (аналогично точке входа исполняемой программы).
    </p>
    <p>
        Модификатор <span class="cour">__stdcall</span> – стандартный для Win API формат:<br>– передача аргументов – через стек<br>– порядок аргументов – прямой (PASCAL) <br>– очистка стека – вызванная подпрограмма<br>– имена – регистро-чувствительные
    </p>
    <p>
        Для прочих экспортируемых функций формат <span class="cour">__stdcall</span> также обычно предпочтителен, но это не обязательно.
    </p>
    <p>
        Экспорт и импорт классов обычно затруднен: требуется согла­сования их описаний и/или явного импорта всех методов. <br>Данные неспецифических типов проблем обычно не вызывают.
    </p>
    <figure class="fig">
        <img src="11-DLL.png">
        <figcaption>Динамически подключаемая библиотека (DLL)</figcaption>
    </figure>



    <h2>11.2.3 Программирование DLL</h2>
    <p>
        Для сред программирования – обычно отдельный тип проекта.
    </p>
    <p>
        Независимо от способа подключения, библиотека имеет точку входа, описываемую функцией:
    <br><span class="cour">&nbsp;BOOL APIENTRY DllMain(<br>&nbsp;&nbsp;	HANDLE hModule, DWORD fCall,<br>&nbsp;&nbsp; 	LPVOID lpReserved);</span>
    </p>
    <p>
    Тип возвращаемого значения <span class="cour">BOOL</span> совместим со стандартным <span class="cour">int</span>, ненулевое значение (<span class="cour">TRUE</span>) соответствует успешному выполнению, нулевое (<span class="cour">FALSE</span>) – неуспешному, в этом случае действие, инициировавшее обращение к точке входа, завершится с ошибкой, если результат для него критичен.
    </p>
    <p>
        Модификатор <span class="cour">APIENTRY</span> стандартный для Win API формат, эквивалентно <span class="cour">__stdcall</span>.
    </p>
    <p>
        <span class="cour">hModule</span> – описатель (handle) библиотечного модуля (аналогично hInstance для WinMain).
    </p>
    <p>
        <span class="cour">fCall</span> – указывает на тип (причину) обращения к точке входа:<br>– <span class="cour">DLL_PROCESS_ATTACH</span> – первичное включение модуля в адресное пространство процесса, модуль может создать необходимые локальные структуры данных (в Win 16 это было практически необходимо) <br>– <span class="cour">DLL_THREAD_ATTACH</span> – создание головным процессом нового потока<br>– <span class="cour">DLL_THREAD_DETACH</span> – завершение одного из потоков– DLL_PROCESS_DETACH – выгрузка модуля из адресного пространства процесса
    </p>
    <p>
        Другие среды программирования могут реализовывать другие подходы. Например:<br>– функция <span class="cour">DllEntryPoint</span>, формат и действие аналогичны (C++ Builder)<br>– предопределенные секции <span class="cour">initialization</span> и <span class="cour">finalization</span> (Delphi)
    </p>
    <p>
        Собранный DLL готов для <b><i>явного</i></b> импорта, но от вызывающей программы потребуется знание имен символов для импорта. Обычно это решается предоставлением соответствующего заголовочного (<span class="cour">*.h</span>) файла и (в оптимистичном случае) документированием.
    </p>
    <p>
        Для <b><i>неявного</i></b> импорта необходимо обеспечить соблюдение единых правил оформления функций, участвующих в интерфейсе, и включение в заголовок <span class="cour">.exe</span>-файла головной программы необходимой информации. Это зависит от среды программирования.
    </p>
    <p>
        Например, в Visual C++:
    </p>
    <p>
        В проекте библиотеки экспортируемые символы объявляются с модификатором <span class="cour">__declspec(dllexport)</span>. 
    </p>
    <p>
        В проекте головной программы импортируемые символы объявляются с модификатором <span class="cour">__declspec(dllimport)</span>, кроме того, в этот проект должен быть включен <span class="cour">.lib</span>-файл, сгенерированный вместе с библиотечным модулем. 
    </p>
    <p>
        Для удобства (выполняется автоматически при создании проекта) модификаторы оформляются в макроподстановки внутри директив условной компиляции в заголовочном (<span class="cour">*.h</span>) файле, который включается в оба проекта (библиотека и головная программа). В результате <span class="cour">.h</span>-файл содержит информацию для компилятора, а <span class="cour">.lib</span>-файл – для компоновщика головной программы (подобно обычному <span class="cour">.obj</span>), и их ошибки будут проявляться на соответствующих стадиях.
    </p>
<pre class="cour">
 #ifdef DLL_SUB_EXPORTS
 #define DLL_SUB_API __declspec(dllexport)
 #else
 #define DLL_SUB_API __declspec(dllimport)
 #endif
 extern DLL_SUB_API char szMyDllData[];
 DLL_SUB_API int MyDllFunction( ... );
 class DLL_SUB_API CMyDllClass { ... };
</pre>
    <p>
        Проблема соглашений об именах (актуально при любом способе импорта): по умолчанию экспортируются «внутренние» имена символов (сигнатуры), не совпадающие с «видимыми» именами, что осложняет связывание разнородных проектов. При использовании «родственных» наборов инструментов проблема может быть решена опциями и директивами. Радикальное решение – явное стандартное описание символов для экспорта.
    </p>
    <p>
        В С-ориентированных средствах – традиционно <span class="cour">.def</span>-файл. Секция <span class="cour">EXPORTS</span> описывает все экспортируемые имена. Здесь описана функция <span class="cour">MyDllFunction()</span>, экспортируемая под этим именем и под индексом <span class="cour">2</span>:
        <br><span class="cour">&nbsp;EXPORTS
        <br>&nbsp;MyDllFunction @2</span>
    </p>
    <p>
        Прототип этой функции в исходном тексте:
        <br><span class="cour">int __stdcall MyDllFunction( ... )</span>
    </p>
    <h2>11.3 Смешанные сборки (Mixed Assembly)</h2>
    <p>
        Основная рекомендованная технология, позволяющая совместить в одном проекте модули .NET и «обычные» (Native Win API). Это может быть актуально, например, в случаях:
    </p>
    <p>
        – модификация и сопровождение продуктов, содержащих «старые» модули (приложения <span class="cour">.exe</span> или библиотеки <span class="cour">.dll</span>) и требующих дополнения их .NET кодом
    </p>
    <p>
        – решение в рамках .NET специфических задач, требующих обращения к Win API и unmanaged кода
    </p>
    <p>
        В рамках MS Visual Studio – только проекты на C++ (поддержка managed и unmanaged версий одновременно).
    </p>
    <figure class="fig">
        <img src="11-Mixed_assembly.png">
        <figcaption>Пример: смешанная сборка-DLL для подключения к приложениям Windows Native</figcaption>
    </figure>
    <h3>Головной модуль – Windows Native (DLL):</h3>
<pre class="cour">
 #include &lt;windows.h&gt;
 #include &lt;stdio.h&gt;
 #include "MyManagedInterface.h"
 #pragma unmanaged
 MyManagedInterface mi;
 BOOL APIENTRY DllMain( … )
 {  
     …  
     mi.MyInterfaceMethod_1( … );  
     mi.MyInterfaceMethod_2( … );  
     …
 }
</pre>
<h3>Подключаемый модуль – managed (MyManagedInterface):</h3>
<pre class="cour">
 #pragma managed
 class MyManagedInterface ( … )
 {  
     …  
     MyInterfaceMethod( … ) { … };  
     MyInterfaceMethod( … ) { … };  
     …
 }
</pre>
<p>
    Точкой входа в unmanaged модуль может быть также WinMain – будет сгенерирован «смешанный» исполняемый файл (<span class="cour">.exe</span>), который будет выполняться самостоятельно.
</p>
<p>
    Вызовы между managed и unmanaged кодом сопровождается <b><i>маршаллингом</i></b> параметров. В вызовах managed методов можно использовать unmanaged указатели. 
</p>
<p>
    Требуется использование ключевых слов – модификаторов параметров <span class="cour">ref</span>, <span class="cour">out</span>.
</p>
<p>
    Второй проиллюстрированный вариант менее актуален, так как задача простого импорта функций DLL (в том числе системных) и вызова их из managed-кода решается штатными средствами:
    <br><span class="cour">&nbsp;[DllImport (”MyDll.dll”)]
    <br>&nbsp;static extern … MyDllFunction( … )</span>

</p>
</body>