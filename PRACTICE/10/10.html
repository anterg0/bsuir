<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<style>
		.cour {
			font-family: 'Courier New', Courier, monospace;
			font-weight: bold;
			font-size: 25pt;
			line-height: 1;
		}

		h1 {
			/*название раздела*/
			font-size: 40pt;
			text-align: center;
		}

		h2 {
			/*название параграфа*/
			font-size: 35pt;
		}

		h3 {
			/*?*/
			font-size: 30pt;
		}

		p {
			font-size: 25pt;
			line-height: 1;
		}

		figure img {
			width: 75%;
			height: 75%;
		}

		.fig {
			align-items: center;
			justify-content: center;
			display: block;
			text-align: center;
			margin-top: 0;
			margin-bottom: 100px;
			font-size: 23pt;
		}

		table,
		th,
		td {
			border: 1px solid black;
			border-collapse: collapse;
			padding: 10px;
			font-size: 25pt;
		}
	</style>

</head>

<body>
	<h1>10 Сокеты и элементы сетевого программирования</h1>
	<h2>10.1 Основы построения и функционирования вычислительных сетей (кратко)</h2>
	<p>Сеть – типичная <b><i>сложная система</i></b> (состоит из подсистем, которые, в свою очередь, также являются
		сложными системами). </p>
	<p>Два основных уровня компонентов сети:
		<br>– базовая сеть передачи данных (СПД) – состоит, в свою очередь, из служебных узлов и каналов связи
		<br>– оконечные узлы (устройства пользователя, терминалы)
	</p>
	<p>Два основных способа организации передачи данных в сетях:
		<br>– с установлением соединения
		– без установления соединения
	</p>




	<p>При передаче <b><i>без установления соединения</i></b> данные передаются в виде законченных самостоятельных
		блоков – <b><i>датаграмм</i></b> (<b><i>datagram</i></b>).
	</p>
	<p>Каждая датаграмма доставляется к получателю по произвольному маршруту и независимо от других датаграмм, причем
		подтверждения о получении (квитирование) не предусматриваются, поэтому не гарантируется ни порядок следования
		датаграмм, ни единственность доставленного экземпляра, ни сам факт доставки – контролируются обычно только
		искажения каждой отдельной датаграммы.
	</p>
	<p>
		Просто, экономично, но для многих применений недостаточно надежно.
	</p>
	<p>Полезное свойство датаграмм – возможность адресовать их более чем одному получателю, в т.ч. всем узлам сети
		(широковещание).
	</p>




	<p>Передача <b><i>с установлением соединения</i></b> – обеспечение целостности и упорядоченности потока передаваемых
		данных. Независимо от способа организации потока данных порции данных доставляются получателю строго в том
		порядке, в котором они были отправлены, а прерывание потока своевременно распознается. Это достигается за счет
		нумерации порций данных и организации встречного потока подтверждений о получении (квитанций). </p>
	<p>Таким образом образуется <b><i>виртуальный канал</i></b> передачи данных, для прикладных программ близкий по
		своим свойствам файлу или потоку ввода-вывода. Вместе с тем потоковая передача сложнее, требует специальных
		процедур установления соединения и дополнительных затрат на контроль его состояния, создает дополнительную
		нагрузку на линии связи в виде встречного потока квитанций.
	</p>




	<p><b><i>Коммутация</i></b> – распределение имеющихся физических каналов передачи данных для создания виртуальных.
		<br>Три основных метода коммутации: </br>
		<br>– Коммутация <b><i>каналов</i></b> – соединение абонентов физическим каналом на время всего сеанса
		взаимодействия; через канал можно передавать поток данных или отдельные сообщения.</br>
		<br>– Коммутация <b><i>сообщений</i></b> – канал передачи (маршрут) формируется заново для каждого отдельного
		блока данных (сообщения); размер сообщения предполагаются достаточно большим и заранее не известным.</br>
		<br>– Коммутация <b><i>пакетов</i></b> – данные передаются в виде множества блоков (пакетов) ограниченного
		(заведомо небольшого) размера, доставляемых независимо друг от друга; фрагментация потока или сообщения на
		пакеты и последующая сборка выполняются автоматически, прозрачно для абонентов.</br>
	</p>




	<p>В современных сетях преобладает коммутация пакетов как более надежная и экономичная. Одной из целей сети Arpanet
		(предшественник Internet) была проверка возможности построения андежной сети передачи данных на основе
		коммутации пакетов.
	</p>




	<p>
		Необходимость <b><i>иерархического</i></b> построения сетей и <b><i>унификации</i></b> в них.
		<br>Необходимость унификации построения разнородных систем и сетей и взаимодействия их друг с другом привела к
		переносу на них концепции открытых систем.</br>
		<br><b><i>Открытая система</i></b> – построена на основе открытых спецификаций.
		<br>Для сетей – открытость средств взаимодействия компонентов сети. Открытая система готова взаимодействовать с
		другими системами с использованием стандартных (унифицированных) правил.</br>
	</p>




	<p><b><i>Модель взаимодействия открытых систем – Open System Interconnection</i></b>, <b><i>OSI</i></b> (принята
		Международной организацией по стандартизации (ISO) в 1983 г.)</p>
	<figure class="fig">
		<img src="./OSI_MODEL.png">
		<figcaption>Модель OSI для вычислительных сетей</figcaption>
	</figure>




	<p>Функции уровней:</p>
	<table>
		<tbody>
			<tr>
				<td>1</td>
				<td>Физический</td>
				<td>Взаимодействие со средой передачи данных на уровне сигналов (модуляция, демодуляция, детектирование
					и т.д.)</td>
			</tr>
			<tr>
				<td>2</td>
				<td>Канальный</td>
				<td>Формирование и распознавание низкоуровневых сообщений (кадров), контроль и, возможно, исправление
					ошибок, низкоуровневая идентификация абонентов (<b><i>MAC</i></b> адреса)</td>
			</tr>
			<tr>
				<td>3</td>
				<td>Сетевой</td>
				<td>Логическая идентификация (адресация) абонентов, перенаправление адресованных данных (маршрутизация)
				</td>
			</tr>
			<tr>
				<td>4</td>
				<td>Транспортный</td>
				<td>Передача данных между абонентами с требуемым качеством и дополнительным сервисом.
					Первые 4 уровня принято объединять в <b><i>транспортную систему</i></b>. Точки доступа к ней принято
					называть <b><i>портами</i></b>.</td>
			</tr>
			<tr>
				<td>5</td>
				<td>Сеансовый</td>
				<td>Установление соединений (сеансов) между абонентами и управление ими</td>
			</tr>
			<tr>
				<td>6</td>
				<td>Уровень представления</td>
				<td>Преобразования форматов данных в соответствии с правилами программного обеспечения следующего 7-го
					уровня в конкретной системе</td>
			</tr>
			<tr>
				<td>7</td>
				<td>Прикладной</td>
				<td>Конечные приложения, прикладные задачи</td>
			</tr>
		</tbody>
	</table>




	<p>
		Сеансовый уровень и уровень представления часто не выделяются как самостоятельные, а их функции выполняют
		соответственно транспортный и прикладной уровни.
		<br>Для <b><i>локальных</i></b> сетей, с учетом их специфики, редуцируются функции маршрутизации (сетевой
		уровень), но усложняется управление доступом к среде передачи (канальный уровень).</br>
	</p>
	<figure class="fig">
		<img src="MODEL_MOD.png">
		<figcaption>Модификация модели для локальных вычислительных сетей</figcaption>
	</figure>




	<p>
		<b><i>Протокол</i></b> – набор правил и процедур взаимодействия между одноименными уровнями различных систем,
		обеспечивают корректную связь участников взаимодействия в сети.
		<br><b><i>Интерфейс</i></b> – набор правил и средств их реализации для взаимодействия между соседними уровнями
		одной системы, обеспечивают возможность модульного построения системы.</br>
		<b><i>Стек</i></b> протоколов в сети – набор протоколов, обслуживающих различные уровни взаимодействия.
		Протоколы в стеке проектируются с расчетом на совместную согласованную работу, но остаются достаточно
		независимыми для возможности замены на альтернативные с сохранением интерфейсов.
	</p>




	<p>Далее будет рассматриваться в основном стек сетевых протоколов, обозначаемый как TCP/IP. В действительности он
		включает больше протоколов, относящихся к четырем уровням, но именно IP и TCP являются для него определяющими.
	</p>




	<p>Инкапсуляция блоков данных (пакетов, сообщений) при прохождении через стек</p>
	<figure class="fig">
		<img src="BLOCK_ENCAPSULATION.png">
		<figcaption>Инкапсуляция блоков данных</figcaption>
	</figure>




	<p>Идентификация участников взаимодействия в сети – вписана в общую модель</p>
	<figure class="fig">
		<img src="INTER_IDENT.png">
		<figcaption>Идентификация участников взаимодействия</figcaption>
	</figure>




	<p>В общем виде:
		<br><b style="font-family: 'Courier New', Courier, monospace">&nbsp;<сетевой адрес>:<протокол>:<порт></b></br>
		(Здесь протокол может быть задан неявно – выбранным способом взаимодействия)
		<b><i>Разрешение адресов</i></b> – преобразование адресов сетевого уровня в адреса канального уровня.
		Сетевые <b><i>имена</i></b>. <b><i>Разрешение имен</i></b> – преобразование сетевых имен в сетевые адреса.
		Службы <b><i>DNS</i></b>, <b><i>NAT</i></b>
	</p>




	<figure class="fig">
		<img src="TCP_IP_OSI.png">
		<figcaption>Сопоставление стеков TCP/IP и OSI</figcaption>
	</figure>




	<p>
		Центральное место – сетевой протокол <b><i>IP</i></b> и транспортные <b><i>TCP</i></b> и <b><i>UDP</i></b>.
		<br><b><i>IP</i></b> – <b><i>I</i></b>nternet <b><i>P</i></b>rotocol (version 4, 6) – сетевой уровень
		<br><b><i>UDP</i></b> – <b><i>U</i></b>ser <b><i>D</i></b>atagram <b><i>P</i></b>rotocol – транспортный уровень
		<br><b><i>TCP</i></b> – <b><i>T</i></b>ransmission <b><i>C</i></b>ontrol <b><i>P</i></b>rotocol – транспортный
		уровень
		<br>В силу особенностей протоколов и их реализаций, можно говорить об устойчивых связках протоколов – UDP+IP и
		особенно TCP+IP.
	</p>




	<h2>10.2 Программный интерфейс</h2>
	<p>
		<b><i>Сокет</i></b> (<b><i>socket</i></b>, букв. гнездо, соединитель) – программный объект, обычно системный,
		абстрагирующий точку доступа к транспортной системе.
		<br>В типичном случае сокет сопоставляется одному из <b><i>портов</i></b> одного из транспортных
		<b><i>протоколов</i></b> и служит удобной для прикладного программирования унифицированной надстройкой над ним.
		Реже используются сокеты, связанные с другими протоколами, либо «сырые» (неспецифицированные).
		<br>Программный интерфейс сокетов появился в BSD Unix и в дальнейшем стал фактическим стандартом для большинства
		систем. Функции работы с сокетами стандартизованы (входят в спецификации POSIX) и практически унифицированы
		между системами, для использующих их программ может быть обеспечена межплатформенная переносимость.
	</p>




	<p>
		<br>Как механизм взаимодействия, сокеты позволяют организовать его в том числе и между системами, в том числе на
		разных платформах (ОС, аппаратное обеспечение и проч.). Однако при этом возможны отличия в поведении некоторых
		функций, типах данных, библиотеках и т.п.
		<br>Реализация:
		<br>– Windows – подсистема Winsocket (Winsock, Winsock2), отдельный DLL и соответствующая библиотека (<span
			class="cour">.lib</span>)
		<br>– Unix – обычно реализация в ядре, библиотека поверх системных вызовов
		<br>Требования к компиляции и сборке (Windows, Visual Studio):
		<br>– заголовочные файлы (основные): <span class="cour">winsock.h</span> или <span
			class="cour">winsock2.h</span>
		<br>– библиотеки IDE <span class="cour">wsock32.lib</span> или <span class="cour">ws2_32.lib</span>
		<br>– системные библиотеки <span class="cour">wsock32.dll</span> или <span class="cour">ws2_32.dll</span>
		<br>– инициализация подсистемы – функция <span class="cour">WSAStartup()</span>
	</p>




	<figure class="fig">
		<img src="MULTIPLEX.png">
		<figcaption>Мультиплексирование сообщений в стеке протоколов TCP/IP</figcaption>
	</figure>




	<p style="text-align: center;">Мультиплексирование сообщений в стеке протоколов TCP/IP</p>
	<p><br>Универсальность интерфейса сокетов требует достаточно сложной его организации с многочисленными настройками.
		<br><b>Характеристики сокета</b>:
		<br><b><i>Тип</i></b> («<b><i>семейство</i></b>») <b><i>протоколов</i></b>, «<b><i>домен</i></b>»
		(<b><i>domain</i></b>) – выбор стека протоколов (например, TCP/IP)
		<br><b><i>Тип</i></b> («<b><i>семейство</i></b>») <b><i>адресации</i></b> – выбор способа идентификации
		участников взаимодействия; обычно определяется стеком протоколов, но потенциально может различаться.
		<br><b><i>Адрес сокета</i></b> – идентификатор сокета как точки взаимодействия, идентификатор использующего его
		процесса; формат адреса зависит от типа адресации
	</p>




	<p>
		<b><i>Тип сокета</i></b> – неявно выбирает протокол взаимодействия в рамках семейства протоколов.
	<p>Сокеты в общем совместимы с файловыми дескрипторами и могут в ряде случаев использоваться в функциях файлового
		ввода-вывода. В Windows эта возможность существенно ограничена, а соответствующий сокету тип принято именовать
		<span class="cour">SOCKET</span> (переопределение от «базового» машинного слова):
		<br><span class="cour">&nbsp;typedef unsigned int SOCKET;</span>
		<br>В Unix-системах практически полная совместимость сокетов файловыми дескрипторами (<span
			class="cour">fd</span>) и взаимозаменяемость их в функциях ввода-вывода (с последовательным доступом,
		подобно каналам).
	</p>




	<p>
		Далее рассматриваются преимущественно переносимые (BSD- и POSIX-совместимые) API сокетов.
		Специфика сокетов Windows затрагивается в минимально необходимом объеме.
	</p>




	<h3>
		Адрес сокета
	</h3>
	<p>
		Реализуется подобие «перегрузки» (в терминологии ООП) структуры адреса, передача структур как аргументов
		<b><i>по указателю</i></b> с <b><i>приведением типа</i></b>.
		<br>«Базовая» структура и «наследник» для адреса «internet»:
		<br><span class="cour">struct sockaddr {
			<br> &nbsp;unsigned short sa_family;</span>//семейство адресации
		<br> <span class="cour">&nbsp;char sa_data[14];</span> //резерв для данных адреса
		<br><span class="cour">};</span>
		<br><span class="cour">struct sockaddr_in {</span> //семейство адресации AF_INET
		<br> <span class="cour">&nbsp;short sin_family;</span> //= AF_INET
		<br> <span class="cour">&nbsp;unsigned short sin_port;</span> //номер порта
		<br> <span class="cour">&nbsp;struct in_addr sin_addr;</span> //значение IP-адреса
		<br> <span class="cour">&nbsp;char sin_zero[8];</span> //заполнитель до 14 байт
		<br><span class="cour">};</span>
	</p>




	<p>
		Сам адрес IP (точнее, IPv4) в зависимости от реализации представляется также структурой, состоящей из одного
		32разрядного слова, или «смесью» (четыре октета, два 16разрядных слова, одно 32разрядное):
	</p>
	<p class="cour">
		struct in_addr {
		<br>&nbsp; unsigned long s_addr;
		<br>};
		<br>struct in_addr {
		<br>&nbsp; union {
		<br>&nbsp;&nbsp; struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;
		<br>&nbsp;&nbsp; struct { u_short s_w1,s_w2; } S_un_w;
		<br>&nbsp;&nbsp; u_long S_addr;
		<br> };
	</p>
	<p>
		Для удобной работы с содержимому этой структуры обычно используются используются функции или макросы.
	</p>




	<p>
		И IP-адрес, и номер порта должны быть записаны в «<b><i>сетевом</i></b>» формате: «старший» (наиболее значимый)
		байт записывается и передается первым – <b><i>MSB first</i></b> или т.н. <b><i>big endian</i></b>
		(<b><i>BE</i></b>) Если они участвуют в вычислениях или в операциях ввода-вывода, необходимо выполнять
		преобразование между «сетевым» и «локальным» форматами (см. ниже).
	</p>
	<p>
		Для сравнения – структура для «локальных» («Unix») адресов (имена в файловой системе):
	</p>
	<p>
		<span class="cour">
			struct sockaddr_un {
		</span>
		//семейство адресации AF_UNIX
		<br>&nbsp;
		<span class="cour">
			sa_family_t sun_family;
		</span>
		// =AF_UNIX
		<br>&nbsp;
		<span class="cour">
			char sun_path[108];
		</span>
		//имя файла и путь
		<br><span class="cour">
			};
		</span>
	</p>




	<p>
		Для заполнения адреса могут использоваться функции (неполный перечень):</p>
	<p class="cour">
		inet_aton(), inet_pton()
		<br>inet_addr()
	</p>
	<p>
		Обратное преобразование – из структуры адреса в строковую запись:
	</p>
	<p class="cour">
		inet_ntoa(), inet_ntop()
	</p>
	<p>
		Разрешение сетевого имени в адрес – фактически обращение к сетевой службе имен DNS:
	</p>
	<p class="cour">
		gethostbyname(), getnameinfo()
	</p>
	</p>




	<h3>Создание сокета</h3>
	<p class="cour">
		&nbsp;int socket(int domain, int type, int protocol);
	</p>
	<h3>Конфигурирование и подготовка сокета</h3>
	<p>
		Связывание сокета с локальным адресом (адресом сетевого интерфейса в локальной системе)
	</p>
	<p class="cour">
		&nbsp;int bind( int sock,
		<br>&nbsp;&nbsp;const struct sockaddr *addr, socklen_t addrlen)
	</p>
	<p>
		Связывание сокета с удаленным («серверным») сокетом
	</p>
	<p class="cour">
		&nbsp;int connect( int sock,
		<br>&nbsp;&nbsp;const struct sockaddr *addr, socklen_t addrlen);
	</p>
	<p>
		«Включение» сокета (для потоковых) с очередью ожидающих запросов:
	</p>
	<p class="cour">
		&nbsp;int listen(int sock, int backlog);
	</p>




	<p>
		Установка и получение параметров (опций) сокета, аргументы зависят от сокета и конкретных опций:
	</p>
	<p class="cour">
		&nbsp;setsockopt(…), getsockopt(…)
	</p>
	<h3>Прием/передача данных</h3>
	<p>
		Прием соединений клиентов (это тоже прием данных!):
	</p>
	<p class="cour">
		&nbsp;int accept(int sock, struct sockaddr *addr, socklen_t *addrlen, int flags)
	</p>
	<p>
		<span class="cour">accept()</span> – прием соединения клиента
	</p>
	<p>
		Это особый случай приема данных: результатом является не собственно прикладные данные, а создание нового
		«клиентского» соединения. Обмен данными будет осуществляться через «клиентское» соединение, а сокет, на котором
		выполнялся accept(), остается доступным для новых соединений.
	</p>




	<p>
		Прием и передача «прикладных» данных:
	</p>
	<p class="cour">
		&nbsp;recv(…), recvfrom(…)
		<br>&nbsp;send(…), sendto(…)
	</p>
	<p>
		Для «потоковых» сокетов возможно также использование обычных «файловых» функций <span class="cour">read()</span>
		и <span class="cour">write()</span>.
	</p>
	<h3>Закрытие сокета</h3>
	<p>
		Обычное закрытие аналогично файлу:
	</p>
	<p class="cour">
		&nbsp;closesocket( int sock)
	</p>
	<p>
		Избирательное закрытие сокета (прием и/или передача):
	</p>
	<p class="cour">
		&nbsp;int shutdown(int sock, int how);
	</p>
	<p>
		<b><i>Низкоуровневое</i></b> управление сокетом (по аналогии с устройствами и файлами):
	</p>
	<p class="cour">
		&nbsp;ioctlsocket(…)
	</p>




	<h3>Прочие вспомогательные функции</h3>
	<p>
		Согласование формата чисел (задача уровня представления в модели OSI) – локальный (<b><i>h</i></b>ost) и сетевой
		(<b><i>n</i></b>etwork) форматы для «коротких» (<b><i>s</i></b>hort) и «длинных» (<b><i>l</i></b>ong) целых
		чисел:
	</p>
	<p class="cour">
		htons(…), htonl(…), ntohs(…), ntohl()
	</p>
	<p>
		Стандартным сетевым считается формат «big endian», характерный для аппаратной архитектуры машин DEC. Архитектура
		Intel x86+ оперирует числами в формате «little endian» (младший байт по младшему адресу), поэтому преобразование
		необходимо.
	</p>




	<h3>Windows Sockets API (WSA)</h3>
	<p>
		Набор функций и типов данных, обеспечивающих работу с сокетами в Windows-системах. Название позже сокращено до
		Winsockets или Winsock. Префикс имен – <span class="cour">WSA*</span>.
	</p>
	<p>
		Первая версия (1.0, 1.1) – реализация, альтернативная общепринятым Berkeley sockets (BSD) с рядом ограничений и
		некоторыми отличиями в поведении.
		<br>Фактически в Windows «обычный» API сокетов реализован поверх Winsock для совместимости, и выбор между
		функциями Winsock и «обычными» – в основном вопрос предпочтений программиста и переносимости написанной
		программы.
	</p>
	<p>
		Необходимо использование как минимум пары функций Winsock – инициализация и деинициализация подсистемы:
	</p>
	<p class="cour">
		&nbsp;WSAStartup( int nVer, WSADATA& pDat);
		<br>&nbsp;WSACleanup();
	</p>




	<p>Вторая версия (2.0 - 2.2.1), Winsock2 – расширенная по сравнению с первой: добавлена поддержка некоторых сетевых
		протоколов и режимов, дополнительные возможности асинхронной работы и «разделения» сокета несколькими
		процессами, и т.д. Сохраняется полная совместимость с первой версией.
		<br>В целом возможности Winsock 2 по некоторым параметрам (например, использование сокектов в функциях файлового
		ввода-вывода) приближены к классическим сокетам, по другим могут их превосходить (например, асинхронные
		операции).
	</p>
	<p>
		В любом случае, возможность программ взаимодействовать посредством сетевых протоколов не зависит ни от
		реализации сокетов, ни от операционной системы, ни от иных локальных особенностей (при условии, что сетевые
		протоколы соответствуют одним и тем же спецификациям).
	</p>




	<h2>10.3 Использование сокетов</h2>
	<p>
		Сетевые приложения обычно строятся в той или иной мере по схеме несимметричного взаимодействия «клиент-сервер»:
	</p>
	<p>
		<b><i>Сервер</i></b> – программа, исполняющая поступающие запросы
	</p>
	<p>
		<b><i>Клиент</i></b> – программа, отсылающая серверу запросы и принимающая результаты их обработки.
	</p>
	<figure class="fig">
		<img src="CLIENT_SERVER_INTER.png">
		<figcaption>Взаимодействие «клиент-сервер»</figcaption>
	</figure>




	<h2>11.3.1 Взаимодействие без установления соединения</h2>
	<p>
		Взаимодействие потенциально симметрично, роли клиента и сервера различаются лишь логикой прикладного уровня. 
	</p>
	<h2>11.3.2 Взаимодействие с установлением соединения</h2>
	<p>
		Взаимодействие принципиально несимметрично на уровне вызовов и использования сокетов.
	</p>
	<p>
		Протокол TCP предусматривает отдельную «точку» (сокет) для приема запросов на соединение и одну или несколько для обмена данными. Встроенная в протокол обработка запроса на соединение (<span class="cour">connect()</span>) включает создание нового соединения между двумя новыми сокетами для обмена данными. Процедура может повторяться многократно, каждый раз создавая новое соединение. Закрытие соединения данных никак не сказывается на «базовой» точке.
	</p>
	<figure class="fig">
		<img src="INTER_WITHOUT_CONNEC.png">
		<figcaption>Взаимодействие без установления соединения</figcaption>
	</figure>
	<figure class="fig">
		<img src="INTER_WITH_CONNEC.png">
		<figcaption>Взаимодействие с установлением соединения</figcaption>
	</figure>




	<h2>10.4 Построение многопользовательских серверов </h2>
	<p>
		Один сервер обычно может обслуживать множество клиентов, а клиент – обращаться сразу к нескольким серверам. Одна и та же программа может играть роль и клиента, и сервера, например, обращаясь к другому серверу в процессе исполнения запросов своих клиентов.
	</p>
	<p>
		Обслуживание сервером нескольких клиентов требует в том или ином виде распараллеливания его работы. При использовании датаграммных сокетов каждое сообщение поступает и может быть обработано независимо от остальных, но при взаимодействии с установлением соединения необходимо специально заботиться о поддержании нескольких соединений.
	</p>
	<p>
		Проблемы – начиная от параллельного приема новых соединений и обслуживания уже установленных.
	</p>




	<h2>10.4.1 Последовательный сервер</h2>
	<p>
		Простейший случай – последовательный сервер:
		<br>– прием запроса на соединение
		<br>– установление соединения
		<br>– обмен данными с клиентом
		<br>– закрытие соединения
		<br>– переход к следующим запросам на соединение
	</p>
	<p>
		Минимальные затраты на проектирование и функционирование.
	</p>
	<p>
		Фактически не предполагает параллельного исполнения запросов клиентов. Применим только в случае принципиально малой длительности и/или низкой интенсивности запросов.
	</p>
	<p>
		Пример эффективного применения: сервер службы datetime.
	</p>




	<h2>10.4.2 Сервер с использованием многозадачности (многопоточности)</h2>
	<figure class="fig">
		<img src="MULTI_SERVER.png">
		<figcaption>Многозадачный многопользовательский сервер</figcaption>
	</figure>




	<p>
		Каждое соединение, включая и ожидание новых запросов на соединение, обслуживается отдельным «подсервером», выполняющимся параллельно с другими.
	</p>
	<p>
		Варианты:
		<br>– многозадачность на уровне процессов – надежность в случае аварийного поведения отдельных соединений, существенные затраты на процессы, затрудненное взаимодействие между «подсерверами»
		<br>– <b><i>многопоточность</i></b> – меньшие затраты, более эффективное взаимодействие между «подсерверами», меньшая (потенциально) устойчивость к сбоям в одном из потоков
		<br>– с <b><i>предварительно созданными</i></b> (<b><i>pre-created</i></b>, <b><i>pre-forked</i></b>) потоками (процессами) – наличие <b><i>пула</i></b> потоков, откуда они выбираются для обслуживания очередного соединения, дополнительное избегание затрат на повторное создание потоков.
	</p>




	<p>
		В целом:
		<br>– логическая «прозрачность» архитектуры и удобство для проектирования
		<br>– хорошая масштабируемость
		<br>– дополнительные затраты на синхронизацию потоков (процессов) и типичные проблемы многозадачного программирования
	</p>




	<h2>10.4.3 Сервер с использованием мультиплексированного ввода-вывода (сервер на основе конечного автомата)</h2>
	<figure class="fig">
		<img src="MULTIPLEX_SERVER.png">
		<figcaption>Сервер с мультиплексированием обработки запросов</figcaption>
	</figure>
	<p>
		Предварительная проверка наличия данных (и готовности к передаче) всех открытых сокетов, прием и обработка имеющихся данных/запросов. Сеанс взаимодействия естественным образом разбивается на ряд состояний и переходов между ними. Сервер в заранее не известном порядке выполняет попеременно фрагменты алгоритмов, относящихся в разным соединениям.
	</p>
	<p>
		В целом:
		<br>– логическая сложность проектирования (в том числе и для обеспечения надежности и отказоустойчивости)
		<br>– возможность реализации без поддержки многозадачности на уровне системы (актуально в прошлом)
	</p>




	<p>Пример – посылка данных (структуры <span class="cour">TFrame</span>) через UDP</p>
<pre class="cour">
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;winsock.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

struct TFrame {
    char cSignature[4];
    unsigned short wData1;
    unsigned long dwData2;
};
struct TFrame Frm;

int main(int argc, char **argv) {
    struct sockaddr_in SockAddrLocal, SockAddrSend;
    SOCKET SockLocal = INVALID_SOCKET;
    struct hostent *pHostEnt;
    int nSockOptBC, nPortRemote, nMsgLen;
    WSADATA WSAData;
    WORD wWSAVer;
    //command line processing
    if (argc < 2) {
        fputs("No enough arguments\n", stderr);
        fputs("Use: UDPSend <addr/name> <port>\n",
              stderr);
        return -1;
    }
    //инициализация подсистемы сокетов
    wWSAVer = MAKEWORD(1, 1); //WinSock version 1.1
    if (WSAStartup(wWSAVer, &WSAData) != 0) {
        fputs("Error initializing WinSock subsystem\n",
              stderr);
        return -1;
    }
    //create local socket
    SockLocal = socket(PF_INET, SOCK_DGRAM, 0);
    if (SockLocal < 0) {
        fputs("Error when creating socket\n", stderr);
        return -1;
    }
    //configure socket: broadcasting is enabled
    nSockOptBC = 1;
    setsockopt(SockLocal, SOL_SOCKET,
               SO_BROADCAST, (char *) (&nSockOptBC),
               sizeof(nSockOptBC));
    //bind socket to "local" address
    memset(&SockAddrLocal, 0, sizeof(SockAddrLocal));
    SockAddrLocal.sin_family = AF_INET;
    SockAddrLocal.sin_addr.s_addr = INADDR_ANY; //all
    SockAddrLocal.sin_port = 0; //"auto" port number
    if (bind(SockLocal,
             (struct sockaddr *) &SockAddrLocal,
             sizeof(SockAddrLocal)) != 0) {
        fputs("Error binding to local address\n",
              stderr);
        return -1;
    }
    //prepare "remote" address
    memset(&SockAddrSend, 0, sizeof(SockAddrSend));
    SockAddrSend.sin_family = AF_INET;
    if (strcmp(argv[1], "255.255.255.255") == 0)
        SockAddrSend.sin_addr.s_addr = INADDR_BROADCAST;
    else {
        SockAddrSend.sin_addr.s_addr =
                inet_addr(argv[1]);
        if (SockAddrSend.sin_addr.s_addr == INADDR_NONE) {
            pHostEnt = gethostbyname(argv[1])
            if (pHostEnt == NULL) {
                fprintf(stderr,
                        "Wrong/unrecognized host: %s\n", argv[1]);
                return -1;
            }
            SockAddrSend.sin_addr =
                    *(struct in_addr *) (pHostEnt->h_addr_list[0]);
        }
    }
    if (sscanf(argv[2], "%u", &nPortRemote) < 1) {
        fprintf(stderr, "Wrong port number: %s\n",
                argv[2]);
        return -1;
    }
    SockAddrSend.sin_port =
            htons((unsigned short) nPortRemote);
    //initialize data generator
    srand(time(NULL));
    fprintf(stderr,
            "Sizeof \"Frame\" structure: %u\n",
            sizeof(TFrame));
    //main function loop
    while (1) {
        //data to be sent
        strncpy(Frm.cSignature, "FRM",
                sizeof(Frm.cSignature));
        Frm.wData1 = rand();
        Frm.dwData2 = (rand() << 16) | rand();
        //send message
        fprintf(stdout,
                "Send to %s:%u: { \"%s\"; %04X; %08X }\n",
                inet_ntoa(SockAddrSend.sin_addr),
                ntohs(SockAddrSend.sin_port),
                &(Frm.cSignature[0]),
                (unsigned) Frm.wData1, (unsigned) Frm.dwData2);
        nMsgLen = sizeof(Frm);
        if (sendto(SockLocal, (const char *) &Frm,
                   nMsgLen, 0, (struct sockaddr *) &SockAddrSend,
                   sizeof(SockAddrSend)) < nMsgLen) {
            fprintf(stderr, "Error sending: \"%s\"\n",
                    &(Frm.cSignature[0]));
            continue;
        }
        Sleep(1000);
    }
    //close all
    fputs("Sender was stopped by user\n", stderr);
    shutdown(SockLocal, 2);
    Sleep(100);
    closesocket(SockLocal);
    SockLocal = INVALID_SOCKET;
    WSACleanup();
    return 0;
}
</pre>
</body>
</html>