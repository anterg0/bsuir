<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <style>
		.cour {
			font-family: 'Courier New', Courier, monospace;
			font-weight: bold;
			font-size: 25pt;
			line-height: 1;
		}
        .courS {
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
			font-size: 15pt;
			line-height: 1;
        }
		h1 {
			/*название раздела*/
			font-size: 40pt;
			text-align: center;
		}

		h2 {
			/*название параграфа*/
			font-size: 35pt;
		}

		h3 {/*пропущенный материал*/
            font-size: 20pt; 
            text-decoration: underline;
            color: #808080;
            text-align: center;
        } 

		p {
			font-size: 25pt;
			line-height: 1;
		}
        .p3 {
            font-size: 25pt;
			line-height: 1;
        }
		figure img {
			width: 75%;
			height: 75%;
		}

		.fig {
			align-items: center;
			justify-content: center;
			display: block;
			text-align: center;
			margin-top: 0;
			margin-bottom: 100px;
			font-size: 23pt;
		}

		table,
		th,
		td {
			border: 1px solid black;
			border-collapse: collapse;
			padding: 10px;
			font-size: 25pt;
		}
	</style>
</head>
<body>
    <h1>12 Средства конфигурирования и управления, элементы системного администрирования</h1>
    <h2>12.1 Конфигурирование и настройка</h2>
    <h2>12.1.1 Общие подходы</h2>
    <p>
        Основной принцип – отделение программ от данных (в т.ч. конфигурационных).
    </p>
    <p>
        Возможные подходы к хранению конфигурационной информации: централизованной и децентрализованныйНа практике подходы не исключают полностью друг друга и нередко комбинируются.
    </p>
    <p>
        <b>Децентрализованный</b> подход – каждое отдельное приложение (группа взаимосвязанных приложений) решают задачи хранения и использования конфигурации самостоятельно и независимо от других. Способ хранения – обычно файл, формат – текстовый (текст с разметкой: .ini, .cfg, XML и т.д.). Гибкость, универсальность, независимость, переносимость. Критическая важность документирования структуры и форматов данных.Возможно наличие специализированных приложений, обеспечивающих UI и API для более удобного доступа к данным; API может также быть предоставлен в виде библиотек, рассчитанных на определенный формат конфигураций (например, поддержка формата .ini-файлов Windows).
    </p>
    <p>
        <b>Централизованный</b> подход – наличие единого хранилища конфигурационных данных, подконтрольного специализиро­ванной службе, которая предоставляет доступ к данным посредством соответствующего API. Унификация доступа, разгрузка прикладных программ от функций управления конфигурациями и интерпретации форматов. Зависимость от качества реализации системной поддержки.
    </p>
    <h2>12.1.2 Реестр Windows – назначение и организация</h2>
    <p>
        <b>Системный реестр</b> (<b>registry</b>) – специальная системная иерархическая база данных, в которой приложения и операционная система могут сохранять информацию:<br>– сведения об аппаратной конфигурации (данные Configuration manager) <br>– сведения об установленных программах и службах<br>– список драйверов и значений их параметров<br>– обслуживание различных административных программ (например, Control Panel)<br>– произвольные данные приложений пользователя
    </p>
    <p>
        Непосредственный доступ к реестру закрыт на уровне файловой системы. Система предоставляет соответствующий API (системные функции) для действий с реестром (с контролем прав доступа).
    </p>
    <p>
        Реестр существовал еще в Windows 3.1, но использовался очень ограниченно. В Win 32 он стал основным средством хранения конфигураций и служебных данных. Реестры различных версий Windows могут считаться совместимыми на уровне поддержки в API.
    </p>
    <p>
        Физический уровень представления реестра – файлы. Их состав и размещение могут различаться в зависимости от версии системы. В Windows 7 это директорий
    </p>
    <p>
        &nbsp;<span class="cour">%windir%\System32\config\</span>
    </p>
    <p>
        и файлы <span class="cour">DEFAULT</span>, <span class="cour">SAM</span>, <span class="cour">SECURITY</span>, <span class="cour">SOFTWARE</span>, <span class="cour">SYSTEM</span>.<br>(В Win 9x имена файлов реестра имели расширение <span class="cour">.DAT</span>.)
    </p>
    <p>
        <b>Hive</b> (букв. «улей») – двоичный образ данных реестра в структурах в памяти; загруженный в память реестр. Hive загружается из файлов реестра и при необходимости выгружается (экспортируется) в файлы.
    </p>
    <p>
        <b>Логический</b> уровень представления – иерархический список (дерево). 
    </p>
    <p>
        Узлы дерева двух видов:<br>– <b>ключи</b> (<b>keys</b>) <br>– <b>значения</b> (<b>values</b>).
    </p>
    <p>
        Каждому ключу принадлежат список нижестоящих ключей (<b>подключей</b>, <b>subkeys</b>) и список значений (возможно, пустые). 
    </p>
    <p>
        Кроме «настоящих» ключей возможны <b>ссылки</b> – они выглядят и используются так же, как и ключи, но фактически указывают на какой-либо уже существующий в реестре ключ. 
    </p>
    <p>
        Глубина дерева ключей ограничена – 512 уровней.
    </p>
    <figure class="fig">
        <img src="12-Реестр-Структура.png">
        <figcaption>Фрагмент структуры реестра</figcaption>
    </figure>
    <p>
        Идентификация ключей в целом аналогична применяемой в файловой системе:
        <br>– имя (Unicode; длина до 255 символов, в т.ч. путь; регистронечувствительное) – в реестре, для локализации и открытия
        <br>– значение дескриптора <span class="cour">HKEY</span> (производный от Handle) – для доступа к уже открытому ключу
    </p>
    <p>
        В силу особенностей реализации доступа к реестру считается, что он начинается с <b>предопределенных</b> (<b>predefined</b>) ключей верхнего уровня: 
        <br>– <span class="cour">HKEY_LOCAL_MACHINE</span> – описание всех конфигураций, зависящих от аппаратного обеспечения компьютера
        <br>– <span class="cour">HKEY_USERS</span> – описание всех конфигураций, зависящих от пользователей компьютера 
        <br>и ссылок на актуальные в текущем сеансе их подключи:
        <br>– <span class="cour">HKEY_CLASSES_ROOT</span> – ссылка на один из подключей <span class="cour">HKEY_LOCAL_MACHINE</span>, описание текущей конфигурации 
        <br>– <span class="cour">HKEY_CURRENT_USER</span> – ссылка на один из подключей <span class="cour">HKEY_USERS</span>, описание конфигурации, соответствующей текущему пользователюа также
        <br>– <span class="cour">HKEY_CURRENT_CONFIG</span> – ссылка на подключ Config в <span class="cour">HKEY_LOCAL_MACHINE</span>
    </p>
    <p>
        В частности, приложениям рекомендуется сохранять свои данные в определенных подключах.
    </p>
    <p>
        – Информация, зависящая от аппаратной конфигурации и общая для всех пользователей:
    </p>
    <p class="cour">
        &nbsp;HKEY_LOCAL_MACHINE\Software\  
        <br>&nbsp;&nbsp;MyCompany\MyProduct\Version_#\...
    </p>
    <p>
        – Информация, зависящая от текущего пользователя и специфичная для него
    </p>
    <p class="cour">
        &nbsp;HKEY_CURRENT_USER\Software\  
        <br>&nbsp;&nbsp;MyCompany\MyProduct\Version_#\...
    </p>
    <p>
        В 64-разрядных версиях Windows, в связи с сохранением параллельно и 32-разрядных подсистем, информация в реестре также частично дублируется – для 64- и 32-разрядной версий компонентов системы и приложений. Логическое отображение (<b>logical view</b>) реестра. Отображаемые (<b>reflected</b>), подменяемые (<b>redirected</b>) и совместно используемые (<b>shared</b>) ключи реестра.
    </p>
    <p>
        <b>Значения</b> – именованные элементы данных в реестре.<br>Идентификатор значения – имя (длина до 260 символов ASCII или 16383 символов Unicode). аналогично именам ключей). <br>Предусмотрено наличие у ключей безымянного «значения <b>по умолчанию</b>» («<b>default</b>»), но создавать такие значения нужно явно, как и любые другие.
    </p>
    <p>
        Значения характеризуются типом:
    </p>
    <table>
		<tbody>
			<tr>
				<td class="cour">REG_BINARY</td>
				<td>«двоичный блок» (массив байт)</td>
			</tr>
			<tr>
				<td class="cour">REG_DWORD</td>
				<td>двойное слово (машинно-зависимый формат)</td>
			</tr>
			<tr>
				<td class="cour">REG_DWORD_LITTLE_ENDIAN</td>
				<td>двойное слово в формате Intel (младший байт по младшему адресу)</td>
			</tr>
			<tr>
				<td class="cour">REG_DWORD_BIG_ENDIAN</td>
				<td>двойное слово в формате DEC (старший байт по младшему адресу)</td>
			</tr>
			<tr>
				<td class="cour">REG_SZ</td>
				<td>ASCIIZ-строка</td>
			</tr>
			<tr>
				<td class="cour">REG_MULTI_SZ</td>
				<td>массив ASCIIZ-строк, признак конца – пустая строка, т.е. два байта '\0' подряд</td>
			</tr>
			<tr>
				<td class="cour">REG_EXPAND_SZ</td>
				<td>ASCIIZ-строка – имя переменной окружения</td>
			</tr>
            <tr>
				<td class="cour">REG_LINK</td>
				<td>ссылка</td>
			</tr>
            <tr>
				<td class="cour">REG_RESOURCE_LIST</td>
				<td>список ресурсов (драйвера)</td>
			</tr>
            <tr>
				<td class="cour">REG_NONE</td>
				<td>тип не определен</td>
			</tr>
		</tbody>
	</table>
    <p>
        Правила при использовании реестра:
    </p>
    <p>
        – В реестр записываются только данные о конфигурации и инициализации приложения, остальные данные должны храниться в другом месте (но трактовка понятия «конфигурационных данных» не конкретизировано);
    </p>
    <p>
        – Данные размером более 2 Кбайт должны храниться в файле, в реестр же записывается только имя и расположение этого файла (предельный размер одного значения в «стандартном формате» реестра – 1 Мбайт, но большой объем реестра сильно снижает эффективность);
    </p>
    <p>
        – В реестре не должен храниться исполняемый код (видимо, следует распространить и на интерпретируемые скрипты);
    </p>
    <p>
        – Данные должны быть по возможности сгруппированы в структуру (вместо отдельных ключей для каждого элемента данных), так как значения занимают меньше места, чем ключи;
    </p>
    <p>
        – При корректном удалении (деинсталляции) приложения оно должно удалить из реестра все свои данные либо дать системе или другому (контролирующему) приложению необходимую для этого информацию.
    </p>
    <p>
        Тем не менее, исправление ошибок и «чистка» реестра – актуальная задача. Как минимум, два основных подхода: ведение базы данных о всей последовательности модификаций реестра с возможностью восстановления предыдущих состояний, и простая сверка всех значений и ссылок на соответствие реальному содержимому диска и составу устройств в системе.
    </p>
    <h2>12.1.3 Пользовательский интерфейс для работы с реестром – утилита Regedit</h2>
    <p>
        Двоичный формат и относительно сложные правила организации реестра требуют для работы с ним специализированных программ. В системе стандартно присутствует утилита <span class="cour">regedit</span>, также существуют и альтернативные.
    </p>
    <p>
        Режимы работы regedit:
    </p>
    <p>
        <b>Интерактивный</b> – используя GUI (отображение дерева реестра, поиск и модификация его узлов)
    </p>
    <p>
        <b>Командный</b> (<b>пакетный</b>) – выполнение «сценариев» (файлы <span class="cour">.reg</span>)
    </p>
    <p>
        Роль сценариев <span class="cour">regedit</span> выполняют файлы данных реестра, они же участвуют в операциях импорта и экспорта. Фактически выполнение сценария соответствует его импорту в реестр.
    </p>
    <p>
        Пример – фрагмент <span class="cour">.reg</span>-файла WinRAR:
    </p>
    <pre class="cour">
REGEDIT4
[HKEY_CURRENT_USER\Software\WinRAR]
...
[HKEY_CURRENT_USER\Software\WinRAR\FileList\ArcColumnWidths]
"name"=dword:00000203
"size"=dword:00000050
"psize"=dword:00000050
"type"=dword:00000078
"mtime"=dword:00000064
"crc"=dword:00000046
...
    </pre>
<h2>12.1.4 Программный интерфейс для работы с реестром – функции API</h2>
<h2>Функции для работы с ключами (выборочно):</h2>
<p>
    Создание нового подключа уже открытого ключа:
</p>
<pre class="cour">
    LSTATUS RegCreateKey(HKEY hKey, 
        LPCTSTR lpSubkeyName,	PHKEY phSubkey)
    LSTATUS RegCreateKeyEx( HKEY hKey, 	
        LPCTSTR lpSubkeyName, DWORD dwReserved, 	
        LPTSTR lpClass, DWORD dwOptions, REGSAM samDesired, 	
        LPSECURITY_ATTRIBUTES lpSecurity, PHKEY phSubkey, 	
        LPDWORD lpDisposition
)
</pre>
<p>
    Открытие существующего подключа уже открытого ключа:
</p>
<pre class="cour">
    LSTATUS RegOpenKey(HKEY hKey, LPCTSTR lpSubkeyName, 	
        PHKEY phSubkey)
    LSTATUS RegOpenKeyEx( HKEY hKey, 	
        LPCTSTR lpSubkeyName, DWORD dwOptions, 	
        REGSAM samDesired, PHKEY phSubkey
    )
</pre>
<p>
    Закрытие открытого ключа:
</p>
<pre class="cour">
    LSTATUS RegCloseKey( HKEY hKey)
</pre>
<p>
    Удаление подключа (по имени) открытого ключа:
</p>
<pre class="cour">
    LSTATUS RegDeleteKey( HKEY hKey,LPCTSTR lpSubkey)
</pre>
<p>
    Принудительная запись содержимого ключа из загруженного образа в файл реестра:
</p>
<pre class="cour">
    LSTATUS RegFlushKey( HKEY hKey)
</pre>
<p>
    Сохранение (экспорт) и загрузка (импорт) данных реестра, используя внешние файлы:
</p>
<pre class="cour">
    LSTATUS RegSaveKey( HKEY hKey, LPCSTR lpFileName, 	
        LPSECURITY_ATTRIBUTE lpSecurity );
    LSTATUS RegLoadKey( HKEY hKey, LPCSTR lpSubkeyName,	
        LPCSTR lpFileName );
</pre>
<p>
    Выгрузка (удаление из образа) заданного подключа:
</p>
<pre class="cour">
    LSTATUS RegUnLoadKey( HKEY hKey, 	
        LPCSTR lpSubkeyName );
</pre>
<p>
    Обновление содержимого ключа данными из файла – вся текущая иерархия ключа удаляется и заменяется на новую, загруженную из файла:
</p>
<pre class="cour">
    LSTATUS RegRestoreKey(HKEY hKey, LPCTSTR lpFileName,
    	DWORD dwFlags );
    LSTATUS RegConnectRegistry(LPTSTR lpMachine,	
        HKEY hKey, PHKEY phConnected );
</pre>
<p>
    Замена файла, из которого восстанавливаются ключи, другим; эффект после перезагрузки:
</p>
<pre class="cour">
    LSTATUS RegReplaceKey( HKEY hKey, LPCSTR lpSubKey, 	
        LPCSTR lpNewFile, LPCSTR lpOldFile );
</pre>
<p>
    Получение списка подключей открытого ключа «перечислением» их по индексам:
</p>
<pre class="cour">
    LSTATUS RegEnumKey( HKEY hKey, DWORD dwIndex, 	
        LPTSTR lpSubkeyName, DWORD cbSubkeyName );
    LSTATUS RegEnumKeyEx( HKEY hKey, DWORD dwIndex, 
    	LPTSTR lpSubkeyName, DWORD cbSubkeyName,
     	LPDWORD lpReserved, LPTSTR lpClass, 
    	LPDWORD lpcbClass, PFILETIME lpLastWriteTime );
</pre>
<h2>Функции для работы со значениями (выборочно):</h2>
<p>
    Получение значения из открытого ключа или его подключа:
</p>
<pre class="cour">
    LSTATUS RegQueryValue( //значение подключа «по умолчанию»
        HKEY hKey, LPCTSTR lpSubkey, LPTSTR lpValue, 
    	PLONG lpcbValue );
    LSTATUS RegQueryValueEx( //значение по имени
    	HKEY hKey, LPTSTR lpValueName, LPDWORD lpReserved, 	
        LPDWORD lpdwType, LPTSTR lpValue, PLONG lpcbValue );
</pre>
<p>
    Список значений открытого ключа (типы и данные):
</p>
<pre class="cour">
    LSTATUS RegQueryMultipleValue(	
        HKEY hKey, PVALENT pValList, DWORD dwValsNum, 
    	LPTSTR lpValBuf, LPDWORD lpdwTotalSize );
</pre>
<p>
    Список значений открытого ключа (имена и данные) «перечислением» их по индексам:
</p>
<pre class="cour">
    LSTATUS RegEnumValue( HKEY hKey, DWORD dwIndex, 
    	LPTSTR lpValName, LPDWORD lpcbValName, 	
        LPDWORD lpReserved, LPDWORD lpType, 	
        LPBYTE lpData, LPDWORD lpcbData );
</pre>
<p>
    Запись (модификация) значения:
</p>
<pre class="cour">
    LSTATUS RegSetKeyValueA(	
        HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName,
    	DWORD dwType, LPCVOID lpData, DWORD cbData );
    LSTATUS RegSetValueExA(	
        HKEY hKey, LPCSTR lpValueName, DWORD Reserved,
    	DWORD dwType, const BYTE *lpData, DWORD cbData );
</pre>
<p>
    Создание оповещения (посредством объекта синхронизации Event) об изменениях заданного значения:
</p>
<pre class="cour">
    LSTATUS RegNotifyChangeKeyValue(	
        HKEY hKey, BOOL bWatchSubtree, 	
        DWORD  dwNotifyFilter, HANDLE hEvent,	
        BOOL fAsynchronous
    );
</pre>
<h2>12.2 Протоколирование (журналирование)</h2>
<h2>12.2.1 Общие подходы</h2>
<p>
    Основная идея: фиксация сведений о событиях (включая ошибки и сбои), происходящих в системе в целом, ее отдельных компонентах, в прикладных программах.
</p>
<p>
    Типичные решаемые журналами задачи:
</p>
<p>
    – Обнаружение и диагностика ошибок и сбоев, отладка
</p>
<p>
    – Восстановление после ошибок и сбоев
</p>
<p>
    – Мониторинг процессов, качественные и количественные оценки их поведения
</p>
<p>
    – Сбор данных для ранней диагностики и оптимизации системы
</p>
<p>
    – Контроль функционирования средств безопасности (попытки нарушения)
</p>
<p>
    Важное значение журналов («логов») для отладки программ и их мониторинга, особенно в реальном («<b>production</b>») режиме работы.
</p>
<p>
    Отдельно – журналируемые файловые системы и СУБД: специфические функции и требования.
</p>
<p>
    <b>Децентрализованное</b> журналирование – приложения ведут журналы самостоятельно, по собственным правилам, обычно в форме текстовых файлов.
</p>
<p>
    <b>Централизованное</b> журналирование – осуществляется единой службой, к которой обращаются все приложения, нуждающиеся в функциях журналирования. Возможность единообразного доступа, использования более эффективного формата хранения данных, обеспечения сохранности и целостности.
</p>
<p>
    Некоторые типичные проблемы в связи с журналированием:
</p>
<p>
    – Дополнительные затраты времени и других вычислительных ресурсов на запись и обслуживание журналов
</p>
<p>
    – Запись в сами журналы может сопровождаться дополнительными ошибками, которые могут мешать основным функциям журналов
</p>
<h2>12.2.2 Подсистема журналирования Windows</h2>
<p>
    <b>Журналы</b> (<b>Event Logs</b>) – в Windows NT начиная с версии 3.1 и всех последующих. <br>В Windows 9x поддержка отсутствовала. 
</p>
<p>
    Единая унифицированная технология протоколирования событий, ошибок и диагностических сообщений для всех программ в системе. 
</p>
<p>
    Три основных журнала:
</p>
<p>
    <b>Журнал приложений</b> (<b>Application</b>) – используется прикладными программами
</p>
<p>
    <b>Системный журнал</b> (<b>System</b>) – используется драйверами и службами
</p>
<p>
    <b>Журнал системы безопасности</b> (<b>Security</b>)
</p>
<p>
    Расположения файлов журнала, а также дополнительные сведения о них и об использующих их программах, содержатся в соответствующих подключах ключа реестра: 
</p>
<pre class="cour">
    \HKEY_LOCAL_MACHINE\SYSTEM\  
        Current Control Set\Services\EventLog
</pre>
<p>
    Событие (Event) – объект или событие, информация о котором заносится в журнал. 
</p>
<p>
    Поддерживаются 5 типов событий, идентифицируемых числовыми константами:
</p>
<table>
    <tbody>
        <tr>
            <td>Сообщения об ошибках</td>
            <td class="cour">EVENTLOG_ERROR_TYPE</td>
            <td>1</td>
        </tr>
        <tr>
            <td>Предупреждения</td>
            <td class="cour">EVENTLOG_WARNING_TYPE</td>
            <td>2</td>
        </tr>
        <tr>
            <td>Информационные сообщения</td>
            <td class="cour">EVENTLOG_INFORMATION_TYPE</td>
            <td>4</td>
        </tr>
        <tr>
            <td>Сообщение аудита – успешная операция</td>
            <td class="cour">EVENTLOG_AUDIT_SUCCESS</td>
            <td>8</td>
        </tr>
        <tr>
            <td>Сообщение аудита – неуспешная операция</td>
            <td class="cour">EVENTLOG_AUDIT_FAILURE</td>
            <td>16</td>
        </tr>
    </tbody>
</table>
<p>
    Данные в журналах структурированы.
</p>
<p>
    Собственно журнал – идентификаторы событий и моменты их возникновения; прочие сведения хранятся в отдельных файлах (редко изменяемая информация):
</p>
<p>
    Файл <b>категорий</b> – отражение классификации событий и особенностей их протоколирования
</p>
<p>
    Файл <b>сообщений</b> – тексты сообщений зарегистрированных событий
</p>
<p>
    Файл <b>параметров</b> – описание параметров зарегистрированных событий
</p>
<p>
    Косвенное обращение к текстовой информации (например, строкам сообщений) упрощает в том числе и многоязыковую поддержку службы журналирования.
</p>
<p>
    Удаление записей из журнала – либо явно, либо посредством лимитов (размер журнала, срок хранения записей).
</p>
<P>
    Интерфейс пользовательского уровня – системная утилита:	<br>&nbsp;&nbsp;Administrative Tools – Computer Management – Event Viewer
</P>
<p>
    Программный интерфейс – несколько групп функций (API). <br>Основные этапы использования журнала: открытие, модифиция (запись, удаление и др.), закрытие. 
</p>
<p>
    Открытие журнала для записи сообщений:
</p>
<pre class="cour">
    HANDLE RegisterEventSource( lpUNCServerName, 
    	lpSourceName );
</pre>
<p>
    Запись об очередном событии (тип и категория события, опциональная дополнительная информация; текст события уже имеется в файле сообщений):
</p>
<pre class="cour">
    ReportEvent( hEventLog, wType, wCategory, dwEventID, 
    	lpUserSid, wNumStrings, dwDataSize, lpStrings, 
        lpRawData );
</pre>
<p>
    Закрытие журнала после записи:
</p>
<pre class="cour">
    BOOL DeregisterEventSource( hEventLog );
</pre>
<p>
    Открытие журнала для чтения и администрирования:
</p>
<pre class="cour">
    HANDLE OpenEventLog( lpUNCServerName, lpSourceName );
</pre>
<p>
    После этого на открытом журнале можно выполнять различные действия:, создание резервной копии, очистку и т.д.:
</p>
<p>
    <span class="cour">ReadEventLog()</span> – чтение<br>
    <span class="cour">BackupEventLog()</span> – создание резервной копии<br>
    <span class="cour">ClearEventLog()</span> – очистка журнала<br>
    и т.д.
</p>
<p>
    Закрытие журнала после администрирования:
</p>
<pre class="cour">
    BOOL CloseEventLog( hEventLog);
</pre>
<p>
    Программы могут самостоятельно регистрировать собственные события со специфическими параметрами. При этом они должны также самостоятельно зарегистрировать в системе соответствующую информацию.
</p>
<p>
    Все файлы, связанные с журналом, представляют собой модули DLL, программный код которых ограничивается единственной (обязательной) пустой головной функцией, например, <span class="cour">DLLMain</span> (имя может зависеть от системы программирования). Эта функция возвращает значение <span class="cour">TRUE</span> (нормальная успешная инициализация модуля). В качестве данных к модулю присоединяется на этапе компоновки (linking) RES-файл, полученный <b>компилятором сообщений</b> <span class="cour">MC</span> из исходного текста сообщений.
</p>
<p>
    Исходный текст сообщений, т.н. MC-файл, представляет собой последовательность текстовых (ASCII) строк и состоит из необязательного заголовка и последовательности блоков описания сообщений. Каждый такой блок начинается с директивы <span class="cour">MessageID</span>, вводящей идентификатор очередного сообщения.
</p>
<p>
    В результате трансляции файла сообщений появляется также заголовочный файл C/CPP с константами – идентификаторами сообщений, который используется затем в прикладных программах.
</p>
<h2>12.3 Сценарии. Интерпретаторы сценариев («оболочки»)</h2>
<p>
    <b>Командная строка</b> – исторически более ранний вариант пользовательского интерфейса (по сравнению с GUI), а в некоторых ОС – и единственный (классический Unix). 
</p>
<p>
    В Windows роль командной строки (и интерпретаторов) относительно невелика в силу особенностей идеологии системы: преобладающий графический интерфейс пользователя; централизация средств управления системой; предпочтение сложных приложений, предоставляющих комплексное решение задач. <br>Тем не менее, в ряде случаев командная строка – более простой, эффективный и прямой способ решения задачи.
</p>
<p>
    Общий вид командной строки:
</p>
<pre class="cour">
    &lt;команда&gt; &lt;аргумент1&gt; &lt;аргумент2&gt; …
</pre>
<p>
    Здесь <span class="cour">&lt;команда&gt;</span> – внутренняя команда интерпретатора или внешняя утилита (программа)
</p>
<p>
    За ввод и выполнение команд отвечает отдельная программа – <b>командный интерпретатор</b> («оболочка», <b>shell</b>). Концепция «оболочки» командной строки оформилась в ОС Unix (Bourne Shell sh и др.) и до сих пор играет важнейшую роль в большинстве Unix-систем.
</p>
<p>
    Командные интерпретаторы в ОС Microsoft:<br>
– <span class="cour">COMMAND.COM</span> (DOS, Win 16, Win 9x)<br>
– <span class="cour">CMD.EXE</span> (Win NT и все последующие)<br>
– PowerShell (версия 2.0 – с Windows 7, позднее 3.0 и т.д.)
</p>
<P>
    <b>Интерактивный</b> режим – ввод команд вручную, последова­тельно, и поочередное их выполнение
</P>
<P>
    <b>Пакетный</b> режим – последовательность команд в файле, который выполняется как исполняемый. <br>Традиционно расширение имени файла для <span class="cour">COMMAND.COM</span> и <span class="cour">CMD.EXE</span> – .<span class="cour">.bat</span> (сокращение от «batch»).
</P>
<p>
    Командный интерпретатор реализует специализированный язык программирования, предназначенный в первую очередь для управления выполнением других команд
</p>
<p>
    Базовая возможность взаимодействия порождаемых процессов – перенаправление результатов выполнения команд (потоков ввода-вывода):
    <br>&nbsp;&gt; и &lt; – передача данных в файл и прием данных из файла
	<br>&nbsp;| – конвейеризация (pipe) из команды в команду
</p>
<h2>12.3.2 PowerShell</h2>
<p>
    <b>PowerShell</b> – расширение командного интерпретатора CMD, сочетает возможность исполнения как традиционных команд (они, впрочем, считаются псевдонимами – «alias»), так и принципиально новых – <b>командлетов</b> (<b>cmdlet</b>), реализует объектную технологию интерфейса, а также имеет ряд синтаксических и других отличий, например существенно лучшую поддержку арифметических и логических операций.
</p>
<p>
    Раздельные 32- и 64-разрядные версии PowerShell.
</p>
<p>
    Частичная совместимость версий:<br>
    – обратная совместимость версий 3, 4 и 5 с версией 2 <br>
    (опция «<span class="cour">–Version 2.0</span>»)<br>
    – неполная совместимость версии 5 с версиями 3 и 4<br>
    – неполная совместимость при использовании разных версий CLR и MS .NET Framework
</p>
<p>
    Открытый исходный текст. Наличие версий PowerShell Core для Linux и MacOS (предполагают наличие уже установленного .NET Core).
</p>
<p>
    Linux: <span class="cour">pwsh</span>; поддерживаются дистрибутивы (как минимум) RedHat/CentOS/Fedora, Debian/Ubuntu, OpenSUSE, ArchLinux; для прочих установка возможна, но не гарантируется.
</p>
<p>
    MacOS: <span class="cour">pwsh</span>; версия ОС 10.12 и выше.
</p>
<p>
    ОС BSD/FreeBSD: существует проект портирования .NET Core и других компонентов, включая PowerShell.
</p>
<p>
    <b>Командлеты</b> (<b>Cmdlets</b>)<br>
    – Унифицированное именование<br>
    – Объектная модель программного интерфейса<br>
    – Связь с Common Language Runtime (<b>CLR</b>), классами .NET
</p>
<p>
    Поддерживаются интерактивный и пакетный режимы работы.
</p>
<P>
    Расширение имени для пакетных файлов (скриптов) PowerShell – <span class="cour">.ps1</span>, <span class="cour">.ps2</span> и т.п. 
</P>
<p>
    По умолчанию, пакетный файл ассоциирован с текстовым редактором, и его выполнение заблокировано. Необходимо явно разрешить выполнение скриптов PowerShell командой в самом PowerShell, это требует полномочий администратора:
</p>
<pre class="cour">
    set-executionpolicy unrestricted
</pre>
<p>
    Некоторые полезные опции интерфейса:
</p>
<p>
    – Автодополнение вводимых строк (клавиша TAB) и история команд
</p>
<p>
    – Копирование текста в окно PowerShell из буфера обмена (правая кнопка «мыши»)
</p>
<p>
    – Прокрутка содержимого окна PowerShell
</p>
<p>
    Например:<br>
    <span class="cour">&nbsp;get-help * > pshelp.txt</span><br>
    (Выводимый и сохраняемый в файле текст будет иметь кодировку Unicode)
</p>
<p>
    Переменные:<br>
    <span class="cour">&nbsp;$d = get-date</span>
</p>
<p>
    Предопределенные имена, например:
    – <span class="cour">$_</span> – имя объекта в цикле-итераторе <span class="cour">foreach</span>
    – <span class="cour">$psversiontable</span> – текущая версия PowerShell
    и т.д.
</p>
<p>
    Доступ к аргументам командной строки: <span class="cour">$args[0]</span>, <span class="cour">$args[1]</span> и т.д. (нумерация аргументов начинается с нуля)
</p>
<p>
    Благодаря доступу к .NET и поддержке форматов данных, включая XML, обеспечивается взаимодействие с различными приложениями и системными службами.
</p>
<p>
    Проблема обеспечения безопасности при использовании скриптовых языков, особенно имеющих доступ достаточно глубоко к интерфейсам системы.
</p>
<h2>
    12.4 Windows Management Instrumentation
</h2>
<p>
    Windows Management Instrumentation (<b>WMI</b>) – набор средств, «инфраструктура» (терминология Microsoft) для управления данными и функционированием Windows-системы. Технически представляет собой специфическую «фирменную» реализацию Web-Based Enterprise Management (<b>WBEM</b>) и использует Common Information Model (<b>CIM</b>). Ранее использовалась собственная технология Distributed Component Object Model (<b>DCOM</b>), в дальнейшем происходила миграция в сторону более общепринятого Simple Object Access Protocol (<b>SOAP</b>), и в версии PowerShell 3.0 присутствует альтернативный набор классов, использующих вместо DCOM основанный на SOAP протокол Windows Remote Management (<b>WinRM</b>). 
</p>
<p>
    Программная модель WMI – набор объектов (со своими свойствами и методами), открывающих доступ к различным компонентам системы и доступных «внешним» программам, в т.ч. и скриптам PowerShell. Таким образом, это полноценный API для управления системой.
</p>
<p>
    Описания объектов хранятся в виде файлов <span class="cour">.mof</span> в формате <b>MOF</b> (Manage Object Format) в директориях:<br>
    <span class="cour">&nbsp;%windir%\System32\wbem\ <br>
    &nbsp;%windir%\SysWOW64\wbem\</span><br>
(<span class="cour">%windir%</span> – «системный» директорий ОС, обычно <span class="cour">C:\Windows\</span>).
</p>
<p>
    Каждый MOF-файл содержит описание одного или (чаще) нескольких <b>классов</b> (<b>classes</b>), которые содержат:<br>
    – <b>методы</b> (<b>methods</b>)<br>
    – <b>свойства</b> (<b>properties</b>)<br>
    – <b>события</b> (<b>events</b>)<br>
    – <b>экземпляры</b> классов (<b>instances</b>). 
</p>
<p>
    MOF-описания загружаются одним из <b>провайдеров</b> (<b>providers</b>), после чего их классы включаются в <b>пространства имен</b> (<b>namespaces</b>), которые представляют собой некоторое подобие иерархической файловой системы. Провайдеры предоставляются как системой, так и отдельными приложениями.
</p>
<figure class="fig">
    <img src="12-WMI.png">
    <figcaption>Программная модель WMI</figcaption>
</figure>
<p>
    В собственном скрипте PowerShell начинать обычно придется с команды:<br>
    <span class="cour">&nbsp;get-WMIObject имя_объекта</span><br>
    например<br>
    <span class="cour">&nbsp;get-WMIObject Win32_Timezone</span>
</p>
<p>
    Полученный объект пока ни для чего не используется, поэтому его содержимое просто выводится в консоль:
</p>
<pre class="courS">
    Bias SettingID                               Caption
    ---- ---------                               ------- 
    180                                         (UTC+03:00) Kaliningrad, Minsk
</pre>
<p>
    Это правило действует для большинства объектов, но не для всех; к тому же для многих классов вывод содержимого класса означает формально выполненную сериализацию, а не удобный для чтения формат. 
</p>
<p>
    Формат вывода можно задать самостоятельно, используя стандартные средства PowerShell: <br>
    <span class="cour">&nbsp;Get-WmiObject \<br>
        &nbsp;&nbsp;-Class Win32_UserAccount -Namespace root/cimv2 \<br>
        &nbsp;&nbsp;| Format-List Name,FullName</span>
</p>
<p>
    (Здесь дополнительно показаны опции: <span class="cour">–Class</span> и <span class="cour">–Namespace</span>. В данном случае их можно было бы опустить: они лишь явным образом подтверждают поведение «по умолчанию».)
</p>
<p>
    Кроме ресурсов и функционала своей (локальной) системы, можно извлекать сведения из других машин в сети, для этого служит опция <span class="cour">–ComputerName</span> (имя «.» обозначает локальную систему). Например, можно попытаться запросить список процессов (как и в предыдущем примере, целесообразно воспользоваться преобразованием выводимых данных):
    <span class="cour"><br>&nbsp;Get-WmiObject \<br>
	    &nbsp;&nbsp;–Class Win32_Process \<br>
	    &nbsp;&nbsp;–ComputerName Name_of_Remote_Computer</span>
</p>
<p>
    Дальнейшее продвижение зависит от владения набором объектов, их свойствами и методами. Полный список доступных объектов:<br>
    <span class="cour">&nbsp;get-WMIObject -list</span><br>
    будет полезен, но не очень удобен из-за слишком большого размера. Например, в Windows 7 насчитывается почти 8 тысяч классов.
</p>
<p>
    В версии PowerShell 3.0 введен параллельный набор команд и классов с префиксами «<span class="cour">cim</span>». В основном он дублирует имевшиеся ранее средства, но в некоторых случаях обеспечивает больше возможностей.
</p>
<p>
    Проблемы при использовании WMI:
</p>
<p>
    – нестабильность содержимого объектов (есть существенные отличия в зависимости от версии Windows) при недостаточно подробном и прозрачном их документировании;
</p>
<p>
    – то же в отношении приложений: от версии к версии могут меняться содержимое классов, предоставляться или не предоставляться провайдеры, и т.п.;
</p>
<p>
    – существующие универсальные, в первую очередь имеющие GUI, приложения для работы с объектами WMI часто бывают медленными и ресурсоемкими из-за того, что загружают и держат в памяти всю обширную иерархию WMI.
</p>
<h2>12.5 Протокол/служба управления сетями SNMP и распределенная база данных MIB</h2>
<p>
    (Рассматривается лишь как пример организации управления распределенной системой.)
</p>
<p>
    <b>Simple Network Management Protocol</b> (<b>SNMP</b>) – «протокол управления сетью», RFC 1157, 3416 и др.
</p>
<p>
    <b>Management Information Base</b> (<b>MIB</b>) – база управляющей информации, RFC 1213, 1450, 1907 и др.
</p>
<p>
    Архитектура «агент-менеджер». Невозможность централизованного хранения всех параметров системы приводит к использованию частичных ее моделей. 
</p>
<p>
    В упрощенном представлении:
</p>
<p>
    MIB – хранение агентом сведений о своем узле в виде иерархии элементов данных унифицированного вида (а также менеджером – выбранного «среза» системы)
</p>
<p>
    SNMP – запросы элементов данных
</p>
<p>
    MIB 2, SNMP 2 – наличие не только информационных, но и управляющих элементов, модификация которых приводит к изменению режима работы узла.
</p>
<h3>Рис. – SNMP и MIB</h3>
</body>